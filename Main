local _Version_ = "0.0.92v"
 
local EggNames = {
	["void-egg"] = "Void Egg",
	["rainbow-egg"] = "Rainbow Egg",
	["nightmare-egg"] = "Nightmare Egg",
	["aura-egg"] = "Aura Egg",
} 

local placeId = game.PlaceId

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
	Name = "Ducky-Hub " .. _Version_,
	Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
	LoadingTitle = "Ducky-Hub",
	LoadingSubtitle = "Welcome!",
	Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

	DisableRayfieldPrompts = true,
	DisableBuildWarnings = true, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

	ConfigurationSaving = {
		Enabled = true,
		FolderName = nil, -- Create a custom folder for your hub/game
		FileName = "DuckyHubConfigs"
	},

	Discord = {
		Enabled = true, -- Prompt the user to join your Discord server if their executor supports it
		Invite = "P49rCFQ7FX", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
		RememberJoins = true -- Set this to false to make them join the discord every time they load it up
	},

	KeySystem = true, -- Set this to true to use our key system
	KeySettings = {
		Title = "Ducky-Hub",
		Subtitle = "Key System",
		Note = "Join our discord to get the key! (https://discord.gg/P49rCFQ7FX)", -- Use this to tell the user how to get a key
		FileName = "Key_DUCKY_HUB", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
		SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
		GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
		Key = {"Free_Kd89KCD2SP9a8jRNK86YCs", "adminaccess"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
	}
})

-- SERVICES

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- VALUES

local Setting_AutoVoidChest = false
local Setting_AutoInfinityChest = false
local Setting_AutoGiantChest = false
local Setting_AutoFreeWheelSpin = false
local Setting_AutoSpinWheel = false
local Setting_AutoClaimPlaytime = false
local Setting_AutoBlowBubble = false
local Setting_AutoSellBubble = false
local Setting_AutoBuyAlienShop = false
local Setting_AutoBuyBlackmarketItems = false
local Setting_SilentAutoPickupables = false
local Setting_IslandSpawnNotifications = false
local Setting_TeleportToPickupables = false

local Setting_ServerHopFarm = false
-- HOP FARM EGGS
local Setting_Flag_ServerHopFarm_VoidEgg25x = false
local Setting_Flag_ServerHopFarm_VoidEgg10x = false
local Setting_Flag_ServerHopFarm_NightmareEgg25x = false
local Setting_Flag_ServerHopFarm_NightmareEgg10x = false
local Setting_Flag_ServerHopFarm_RainbowEgg25x = false
local Setting_Flag_ServerHopFarm_RainbowEgg10x = false
local Setting_Flag_ServerHopFarm_AuraEgg = false
local Setting_FallbackServerHopper = false

-- TELEPORTING FUNCS

local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")

httprequest = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request

local triedServers = {}
local maxRetries = 5

local function ServerHop_IY(retries)
	retries = retries or 0

	if retries >= maxRetries then
		warn("Serverhop", "Max retry attempts reached. Stopping.")
		return
	end

	if not httprequest then
		warn("Incompatible Exploit", "Your exploit does not support this command (missing request)")
		return
	end

	local servers = {}
	local req = httprequest({
		Url = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100&excludeFullGames=true", game.PlaceId)
	})
	local body = game:GetService("HttpService"):JSONDecode(req.Body)

	if body and body.data then
		for _, v in ipairs(body.data) do
			if type(v) == "table" and tonumber(v.playing) and tonumber(v.maxPlayers)
				and v.playing < v.maxPlayers and v.id ~= game.JobId and not triedServers[v.id] then
				table.insert(servers, v.id)
			end
		end
	end

	if #servers > 0 then
		local pickedServer = servers[math.random(1, #servers)]
		triedServers[pickedServer] = true

		local success, err = pcall(function()
			game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, pickedServer, game.Players.LocalPlayer)
		end)

		if not success then
			warn("Teleport failed:", err)
			warn("Retrying in 15 seconds...")
			task.wait(15)
			ServerHop_IY(retries + 1)
		end
	else
		warn("No suitable servers found. Retrying in 15 seconds...")
		task.wait(15)
		ServerHop_IY(retries + 1)
	end
end




local function getPublicServers()
	local url = ("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100"):format(placeId)
	local success, response = pcall(function()
		return HttpService:JSONDecode(game:HttpGet(url))
	end)

	if success and response and response.data then
		return response.data
	else
		return {}
	end
end

local function HopServer()
	local servers = getPublicServers()
	local currentJobId = game.JobId

	warn("Attempting to hop server!")

	for _, server in pairs(servers) do
		if server.playing < server.maxPlayers and server.id ~= currentJobId then
			TeleportService:TeleportToPlaceInstance(placeId, server.id, game.Players.LocalPlayer)
			return
		end
	end
end

-- MAIN WHILE LOOP

local Loop = task.spawn(function()
	while true do

		if Setting_AutoVoidChest == true then
			ReplicatedStorage.Shared.Framework.Network.Remote.Event:FireServer("ClaimChest", "Void Chest", true)
		end

		if Setting_AutoInfinityChest == true then
			ReplicatedStorage.Shared.Framework.Network.Remote.Event:FireServer("ClaimChest", "Infinity Chest", true)
		end

		if Setting_AutoGiantChest == true then
			ReplicatedStorage.Shared.Framework.Network.Remote.Event:FireServer("ClaimChest", "Giant Chest", true)
		end
		
		if Setting_AutoFreeWheelSpin == true then
			ReplicatedStorage.Shared.Framework.Network.Remote.Event:FireServer("ClaimFreeWheelSpin")
		end
		
		if Setting_AutoFreeWheelSpin == true then
			ReplicatedStorage.Shared.Framework.Network.Remote.Function:InvokeServer("WheelSpin")
		end
		
		if Setting_AutoClaimPlaytime == true then
			for Index = 1, 9 do
				ReplicatedStorage.Shared.Framework.Network.Remote.Function:InvokeServer("ClaimPlaytime", Index)
			end
		end
		
		if Setting_AutoSellBubble == true then
			ReplicatedStorage.Shared.Framework.Network.Remote.Event:FireServer("SellBubble")
		end
		
		if Setting_AutoBuyBlackmarketItems == true then
			for Index = 1, 3 do
				ReplicatedStorage.Shared.Framework.Network.Remote.Event:FireServer("BuyShopItem", "shard-shop", Index)
			end
		end
		
		if Setting_AutoBuyAlienShop == true then
			for Index = 1, 3 do
				ReplicatedStorage.Shared.Framework.Network.Remote.Event:FireServer("BuyShopItem", "alien-shop", Index)
			end
		end

		task.wait(5)
	end
end)

local Loop_Fast = task.spawn(function()
	while true do
		if Setting_AutoBlowBubble == true then
			ReplicatedStorage.Shared.Framework.Network.Remote.Event:FireServer("BlowBubble")
		end

		task.wait(0.25)
	end
end)

--[[local Loop_PickupablesAuto = task.spawn(function()
	while true do
		if Setting_TeleportToPickupables == true then
			for _, Pickupable in workspace.Rendered:GetChildren()[12]:GetChildren() do
				local Name = Pickupable.Name
				local PickupablePart = Pickupable:FindFirstChildOfClass("Part")
				local PickupableMeshPart = Pickupable:FindFirstChildOfClass("MeshPart")
				
				if PickupablePart then
					game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = PickupablePart.CFrame + Vector3.new(0, 8, 0)
				elseif PickupableMeshPart then
					game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = PickupableMeshPart.CFrame + Vector3.new(0, 8, 0)
				end

				task.wait(2)
			end
		end

		task.wait(0.5)
	end
end)
]]

local TweenService = game:GetService("TweenService")

local Loop_PickupablesAuto = task.spawn(function()
	while true do
		if Setting_TeleportToPickupables == true then
			
			game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true
			
			for _, Pickupable in workspace.Rendered:GetChildren()[12]:GetChildren() do
				if Setting_TeleportToPickupables == true then
					local HRP = game.Players.LocalPlayer.Character.HumanoidRootPart
					local Name = Pickupable.Name
					local PickupablePart = Pickupable:FindFirstChildOfClass("Part")
					local PickupableMeshPart = Pickupable:FindFirstChildOfClass("MeshPart")

					if PickupablePart then
						local distance = (HRP.Position - PickupablePart.Position).Magnitude
						local tweenTime = (distance / 60)
						
						TweenService:Create(HRP, TweenInfo.new(tweenTime, Enum.EasingStyle.Linear), {CFrame = PickupablePart.CFrame}):Play()
						
						task.wait(tweenTime + 0.4)
					elseif PickupableMeshPart then
						local distance = (HRP.Position - PickupableMeshPart.Position).Magnitude
						local tweenTime = (distance / 60)
						
						TweenService:Create(HRP, TweenInfo.new(tweenTime, Enum.EasingStyle.Linear), {CFrame = PickupableMeshPart.CFrame}):Play()
						
						task.wait(tweenTime + 0.4)
					end
			
				else
					game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false
				end	
			end
		else
			game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false
		end

		task.wait(1)
	end
end)

-- FUNCTIONS

local Logs_Hook = "https://discord.com/api/webhooks/1362702270084550780/1TK0CX2K2hy3pVLdzcVLWxY-POhbWi9if-89JZqVWVh0OaS1ykwzBYbtYlkhTq7lDbSj"
local Testing_Hook = "https://discord.com/api/webhooks/1362552545343439081/jvNgkuU4VFETKI-0ZnQfo1-IxDHetD6OU1T7qQPL1HHxaBh4OB_HLjROipa3KNamnvEJ"
local Rare_Islands_Hook = "https://discord.com/api/webhooks/1362693689943654502/zX6vmw-AbGOdn_mm8qtrhnBCZdo6wcmayLZisiqUpszAAT7oUbolA5Ag9LhVYI1WdGhs"


function Message(url, message)
	local http = game:GetService("HttpService")
	local headers = {
		["Content-Type"] = "application/json"
	}
	local data = {
		["content"] = message,
	}

	local body = http:JSONEncode(data)
	local response = request({
		Url = url,
		Method = "POST",
		Headers = headers,
		Body = body
	})
end

function Webhook(url, embed)
	local http = game:GetService("HttpService")
	local headers = {
		["Content-Type"] = "application/json"
	}
	local data = {
		["embeds"] = {
			{
				["title"] = embed.title,
				["description"] = embed.description,
				["color"] = embed.color,
				["fields"] = embed.fields,
				["footer"] = {
					["text"] = embed.footer.text
				}
			}
		}
	}
	local body = http:JSONEncode(data)
	local response = request({
		Url = url,
		Method = "POST",
		Headers = headers,
		Body = body
	})
end

function GlobalEggWebhook(Island, Luck, Timer, IslandHeight)
	if Island == "void-egg" or Island == "rainbow-egg" or Island == "nightmare-egg" or Island == "aura-egg" then
		if Luck == "x25" then	
			local Embed = {
				["title"] = "âœ¨ Rare Egg Found!",
				["description"] = "",
				["fields"] = {
					{
						["name"] = "ðŸ¥š Egg Name",
						["value"] = "```" .. tostring(Island) .. "```",
					},
					{
						["name"] = "âŒš Time Left",
						["value"] = "```" .. Timer .. "```",
					},
					{
						["name"] = "ðŸ€ Luck Multiplier",
						["value"] = "```" .. Luck .. "```",
					},
					{
						["name"] = "ðŸŽˆ Height",
						["value"] = "```" .. math.floor(IslandHeight) .. "```",
					},
					{
						["name"] = "ðŸ”‘ Server Link",
						["value"] = "```roblox://placeId=" .. tostring(placeId) .. "&gameInstanceId=" .. tostring(game.JobId) .. "```",
					},

				},
				["color"] = 16777215,
				["footer"] = {
					["text"] = tostring(os.date("%H:%M:%S")) 
				},
			}

			Webhook(Rare_Islands_Hook, Embed)
		end
	end
end

workspace.Rendered.Rifts.ChildAdded:Connect(function(IslandObject)
	task.wait(10)
	
	local IslandName = IslandObject.Name
	local IslandHeight = math.floor(IslandObject.Display.CFrame.Y)
	
	local Luck = nil
	local Timer = IslandObject.Display.SurfaceGui.Timer.Text
	
	if IslandObject.Display.SurfaceGui:FindFirstChild("Icon") then
		Luck = IslandObject.Display.SurfaceGui:FindFirstChild("Icon"):FindFirstChild("Luck").Text
	end

	if Setting_IslandSpawnNotifications == true then
		if Luck then
			Rayfield:Notify({
				Title = "New Island Detected!",
				Content = IslandName .. " " .. Luck .. " (" .. IslandHeight .. "m) (" .. Timer .. ")",
				Image = 0,

				OnClick = function()

				end,
			})
		else
			Rayfield:Notify({
				Title = "New Island Detected!",
				Content = IslandName .. " (" .. IslandHeight .. "m) (" .. Timer .. ")",
				Image = 0,

				OnClick = function()

				end,
			})
		end
	end


	GlobalEggWebhook(IslandObject, Luck, Timer, IslandHeight)
end)

function Check_Islands_OnServer()
	local IslandsTable = {}
	
	--[[  IslandsTable = {
		[1] = {egg_name, egg_luck, egg_cframe, egg_time, egg_height}
	}]]
	
	for _, Island in workspace.Rendered.Rifts:GetChildren() do
		if Island:FindFirstChild("Display") then
			if Island.Display.SurfaceGui:FindFirstChild("Icon") then
				if Island.Display.SurfaceGui.Icon:FindFirstChild("Luck") then
					
					local Name = Island.Name
					local Luck = Island.Display.SurfaceGui.Icon.Luck.Text
					local Timer = Island.Display.SurfaceGui.Timer.Text
					local Height = Island.Display.CFrame.Y
					local EggCFrame = Island.Display.CFrame
					
					table.insert(IslandsTable, {Name, Luck, EggCFrame, Timer, Height})
				end
			end
		end
	end
	
	warn("-------------- ISLANDS TABLE --------------")
	test_print_table(IslandsTable)
	return IslandsTable 
end


--[[local Setting_Flag_ServerHopFarm_VoidEgg25x = false
local Setting_Flag_ServerHopFarm_VoidEgg10x = false
local Setting_Flag_ServerHopFarm_NightmareEgg25x = false
local Setting_Flag_ServerHopFarm_NightmareEgg10x = false
local Setting_Flag_ServerHopFarm_RainbowEgg25x = false
local Setting_Flag_ServerHopFarm_RainbowEgg10x = false
local Setting_Flag_ServerHopFarm_AuraEgg = false]]

function Get_Table_Of_LF_Eggs()
	local LF_Eggs_Table = {}
	
		if Setting_Flag_ServerHopFarm_VoidEgg25x == true then
			table.insert(LF_Eggs_Table, {"void-egg", "x25"})
		end 	
		
		if Setting_Flag_ServerHopFarm_VoidEgg10x == true then
			table.insert(LF_Eggs_Table, {"void-egg", "x10"})
		end 	
		
		if Setting_Flag_ServerHopFarm_NightmareEgg25x == true then
			table.insert(LF_Eggs_Table, {"nightmare-egg", "x25"})
		end 	
		
		if Setting_Flag_ServerHopFarm_NightmareEgg10x == true then
			table.insert(LF_Eggs_Table, {"nightmare-egg", "x10"})
		end 	
		
		if Setting_Flag_ServerHopFarm_RainbowEgg25x == true then
			table.insert(LF_Eggs_Table, {"rainbow-egg", "x25"})
		end 	

		if Setting_Flag_ServerHopFarm_RainbowEgg25x == true then
			table.insert(LF_Eggs_Table, {"rainbow-egg", "x10"})
		end 
		
		if Setting_Flag_ServerHopFarm_AuraEgg == true then
			table.insert(LF_Eggs_Table, {"aura-egg", "x10"})
		end 
	
	warn("-------------- LF EGGS TABLE --------------")
	test_print_table(LF_Eggs_Table)
	return LF_Eggs_Table
end


function test_print_table(tbl_)
	local tablee = tbl_
	for _, v in tablee do
		warn(v)
		for _, x in v do
			print(x)
		end
	end
end


workspace.Rendered:GetChildren()[12].ChildAdded:Connect(function(Pickupable)
	if Setting_SilentAutoPickupables == true then
		task.spawn(function()
			local Name = Pickupable.Name
			
			--Pickupable.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame -- maybe?
			ReplicatedStorage.Remotes.Pickups.CollectPickup:FireServer(Name)
			wait(1)
			Pickupable:Destroy()
		end)
	end
end)

-- FARMING TAB

local Tab_Farming = Window:CreateTab("Farming") -- Title, Image
	
	local Section_Bubbles = Tab_Farming:CreateSection("Bubbles")
	
		local Toggle_AutoBubbleBlow = Tab_Farming:CreateToggle({
			Name = "Auto Blow Bubbles",
			CurrentValue = false,
			Flag = "Flag_AutoBubbleBlow", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_AutoBlowBubble = Value
			end,
		})

		local Toggle_AutoSellBubble = Tab_Farming:CreateToggle({
			Name = "Auto Sell Bubbles",
			CurrentValue = false,
			Flag = "Flag_AutoSellBubble", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_AutoSellBubble = Value
			end,
		})
	
	local Section_Pickupables = Tab_Farming:CreateSection("Pickupables")
	
		local Toggle_SilentAutoPickupables = Tab_Farming:CreateToggle({
			Name = "Silently Pickup Coins & Gems That Spawn Near You",
			CurrentValue = false,	
			Flag = "Flag_SilentAutoPickupables", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_SilentAutoPickupables = Value
			end,
		})
		
		local Toggle_TeleportToPickupables = Tab_Farming:CreateToggle({
			Name = "Fly To Nearby Pickupables",
			CurrentValue = false,	
			Flag = "Flag_TeleportToPickupables", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_TeleportToPickupables = Value
			end,
		})


	
	local Section_Automatic = Tab_Farming:CreateSection("Chests")
	
		local ChestParagraph = Tab_Farming:CreateParagraph({Title = "Warning!", Content = "Auto chests require buffs mastery level 15 to work!"})

		local Toggle_AutoVoidChest = Tab_Farming:CreateToggle({
			Name = "Auto Void Chest",
			CurrentValue = false,
			Flag = "Flag_AutoVoidChest", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_AutoVoidChest = Value		
			end,
		})
				
		local Toggle_AutoGiantChest = Tab_Farming:CreateToggle({
			Name = "Auto Giant Chest",
			CurrentValue = false,
			Flag = "Flag_AutoGiantChest", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_AutoGiantChest = Value
			end,
		})

		local Toggle_AutoInfinityChest = Tab_Farming:CreateToggle({
			Name = "Auto Infinity Chest",
			CurrentValue = false,
			Flag = "Flag_AutoInfinityChest", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_AutoInfinityChest = Value
			end,
		})
		
		
	local Section_Automatic = Tab_Farming:CreateSection("Rewards")

		local Toggle_AutoFreeWheelSpin = Tab_Farming:CreateToggle({
			Name = "Auto Claim Free Wheel Spin",
			CurrentValue = false,
			Flag = "Flag_AutoFreeWheelSpinClaim", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_AutoFreeWheelSpin = Value
			end,
		})

		--[[local Toggle_AutoSpinWheel = Tab_Farming:CreateToggle({
			Name = "Auto Spin Wheel",
			CurrentValue = false,
			Flag = "Flag_AutoSpinWheel", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				if Value == true then
					Setting_AutoSpinWheel = true
				elseif Value == false then
					Setting_AutoSpinWheel = false
				end
			end,
		})]]
		
		local Toggle_AutoClaimPlaytime = Tab_Farming:CreateToggle({
			Name = "Auto Claim Playtime Rewards",
			CurrentValue = false,
			Flag = "Flag_AutoClaimPlaytime", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_AutoClaimPlaytime  = Value
			end,
		})
		
	local Selection_Shops = Tab_Farming:CreateSection("Shops")
		
		local Toggle_AutoBuyBlackmarket= Tab_Farming:CreateToggle({
			Name = "Auto Buy Blackmarket Items",
			CurrentValue = false,
			Flag = "Flag_AutoBuyBlackmarketItems", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_AutoBuyBlackmarketItems  = Value
			end,
		})
	
		local Toggle_AutoBuyAlienShop = Tab_Farming:CreateToggle({
			Name = "Auto Buy Alien Shop Items",
			CurrentValue = false,
			Flag = "Flag_AutoBuyAlienShop", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_AutoBuyAlienShop  = Value
			end,
		})

		


		
local Tab_EggFarm = Window:CreateTab("Egg Farm") -- Title, Image

	local Section_ServerHopFarmInfo = Tab_EggFarm:CreateSection("Server Hop Farm - Info")
		
		local WarningLabel = Tab_EggFarm:CreateLabel("This feature is experimental. Not reccomended to afk for longer periods of time!", 134076038612470, Color3.fromRGB(255, 151, 33), true) -- Title, Icon, Color, IgnoreTheme
		local WarningLabel2 = Tab_EggFarm:CreateLabel("This feature is experimental. Not reccomended to afk for longer periods of time!", 134076038612470, Color3.fromRGB(255, 151, 33), false) -- Title, Icon, Color, IgnoreTheme
		local HopFarmParagraph = Tab_EggFarm:CreateParagraph({Title = "How does this work?", Content = "This feature will change servers untill it finds the egg you are looking for, then it will open it till the island dissapears."})
		local HopFarmWarningParagraph = Tab_EggFarm:CreateParagraph({Title = "!!! WARNING !!!", Content = "You need to add this script to the 'auto execute' list of your executor to make the server hop feature work properly!!! It is also reccomended to have the 'Zen' area unlocked to make the feature more efficient!"})
			
	local Section_ServerHopFarmEggSelection = Tab_EggFarm:CreateSection("Server Hop Farm - Egg Selection")
		
		local HopFarmParagraph = Tab_EggFarm:CreateParagraph({Title = "Selection", Content = "Select the eggs you want to open! It is NOT reccomended to select 25x luck eggs only due to the possibility of getting rate limited by roblox (Script can possibly break)"})
		
		local InfoLabel = Tab_EggFarm:CreateLabel("It is NOT reccomended to select 25x luck eggs only due to the possibility of getting rate limited by roblox while searching for the server (High chance of breaking)", 91136665328764, Color3.fromRGB(130, 195, 255), true) -- Title, Icon, Color, IgnoreTheme
		local InfoLabel3 = Tab_EggFarm:CreateLabel("It is reccomended to turn OFF bubble gravity in BGSI settings for better efficiency!", 91136665328764, Color3.fromRGB(130, 195, 255), true) -- Title, Icon, Color, IgnoreTheme


		local Toggle_Flag_ServerHopFarm_VoidEgg10x = Tab_EggFarm:CreateToggle({
				Name = "Void Egg (x10)",
				CurrentValue = false,
				Flag = "Flag_ServerHopFarm_VoidEgg10x", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
				Callback = function(Value)
					Setting_Flag_ServerHopFarm_VoidEgg10x = Value
				end,
			})
			
		local Toggle_Flag_ServerHopFarm_VoidEgg25x = Tab_EggFarm:CreateToggle({
			Name = "Void Egg (x25)",
			CurrentValue = false,
			Flag = "Flag_ServerHopFarm_VoidEgg25x", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_Flag_ServerHopFarm_VoidEgg25x = Value
			end,
		})
		
		local Toggle_Flag_ServerHopFarm_NightmareEgg10x = Tab_EggFarm:CreateToggle({
			Name = "Nightmare Egg (x10)",
			CurrentValue = false,
			Flag = "Flag_ServerHopFarm_NightmareEgg10x", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_Flag_ServerHopFarm_NightmareEgg10x = Value
			end,
		})
				
		local Toggle_Flag_ServerHopFarm_NightmareEgg25x = Tab_EggFarm:CreateToggle({
			Name = "Nightmare Egg (x25)",
			CurrentValue = false,
			Flag = "Flag_ServerHopFarm_NightmareEgg25x", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_Flag_ServerHopFarm_NightmareEgg25x = Value
			end,
		})
		
		local Toggle_Flag_ServerHopFarm_RainbowEgg10x = Tab_EggFarm:CreateToggle({
			Name = "Rainbow Egg (x10)",
			CurrentValue = false,
			Flag = "Flag_ServerHopFarm_RainbowEgg10x", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_Flag_ServerHopFarm_RainbowEgg10x = Value
			end,
		})

		local Toggle_Flag_ServerHopFarm_RainbowEgg25x = Tab_EggFarm:CreateToggle({
			Name = "Rainbow Egg (x25)",
			CurrentValue = false,
			Flag = "Flag_ServerHopFarm_RainbowEgg25x", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_Flag_ServerHopFarm_RainbowEgg25x = Value
			end,
		})

		local Toggle_Flag_ServerHopFarm_AuraEgg = Tab_EggFarm:CreateToggle({
			Name = "Aura Egg",
			CurrentValue = false,
			Flag = "Flag_ServerHopFarm_AuraEgg", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_Flag_ServerHopFarm_AuraEgg = Value
			end,
		})
		
	local Section_ServerHopFarmToggle = Tab_EggFarm:CreateSection("Server Hop Farm - Toggle")

		local HopFarmReminderParagraph = Tab_EggFarm:CreateParagraph({Title = "Warning", Content = "Make sure to select the eggs you want to hatch before turning on!"})

		local Button_Rejoin = Tab_EggFarm:CreateButton({
			Name = "Rejoin Server (Use after enabling)",
			Callback = function()
				TeleportService:Teleport(placeId)
			end,
		})

		local Toggle_ServerHopFarm = Tab_EggFarm:CreateToggle({
			Name = "Server Hopper Farm",
			CurrentValue = false,
			Flag = "Flag_ServerHopFarm", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_ServerHopFarm = Value
			end,
		})
		
	local Section_ServerHopFarmToggle = Tab_EggFarm:CreateSection("Server Hop Farm - Fallback")
	
		local InfoLabel2 = Tab_EggFarm:CreateLabel("Auto start opening void eggs when there is an error with the server hop farm. (HIGHLY RECOMMENDED)", 91136665328764, Color3.fromRGB(130, 195, 255), false) -- Title, Icon, Color, IgnoreTheme
		
		local Toggle_FallbackServerHopper = Tab_EggFarm:CreateToggle({
			Name = "Fallback To Void Egg",
			CurrentValue = false,
			Flag = "Flag_FallbackServerHopper", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_FallbackServerHopper = Value
			end,
		})


local Tab_Islands = Window:CreateTab("Islands") -- Title, Image

	local Section_Notifications = Tab_Islands:CreateSection("Notifications")

		local Toggle_IslandSpawnNotifications = Tab_Islands:CreateToggle({
			Name = "Get Notifications When New Islands Appear",
			CurrentValue = false,
			Flag = "Flag_IslandSpawnNotifications", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
			Callback = function(Value)
				Setting_IslandSpawnNotifications  = Value
			end,
		})

local Tab_Misc = Window:CreateTab("Misc") -- Title, Image

	local Section_Unlockables = Tab_Misc:CreateSection("Unlockables")
			
	local Button_UnlockIslands = Tab_Misc:CreateButton({
			Name = "Unlock All Islands",
			Callback = function()
				for _, IslandFolders in workspace.Worlds["The Overworld"].Islands:GetChildren() do
					game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = IslandFolders.Island.UnlockHitbox.CFrame
					task.wait(0.5)
				end
			end,
	})
	
	local Section_Info = Tab_Misc:CreateSection("Info")
	
	local DiscordParagraph = Tab_Misc:CreateParagraph({Title = "Discord Server", Content = "https://discord.gg/P49rCFQ7FX"})
	local VersionParagraph = Tab_Misc:CreateParagraph({Title = "Script Version", Content = _Version_})


--- AFTER JOINING SERVER

local LogEmbed = {
	["title"] = "Launch Log",
	["description"] = "",
	["fields"] = {
		{
			["name"] = "Username",
			["value"] = "```" .. game.Players.LocalPlayer.Name .."```",
		},
		{
			["name"] = "Server Link",
			["value"] = "```roblox://placeId=" .. tostring(placeId) .. "&gameInstanceId=" .. tostring(game.JobId) .. "```",
		},

	},
	["color"] = 16777215,
	["footer"] = {
		["text"] = tostring(os.date("%H:%M:%S")) 
	},
}

Webhook(Logs_Hook, LogEmbed)
--Message(Logs_Hook, "`**" .. tostring(os.date("%H:%M:%S"))  .. " - Launched by: " .. game.Players.LocalPlayer.Name .. " (SERVER_ID: " .. game.JobId .. "**`")
Rayfield:LoadConfiguration()

--------------------------

task.spawn(function()
	if Setting_ServerHopFarm == true then
		local Players = game:GetService("Players")
		local LocalPlayer = Players.LocalPlayer
		local TweenService = game:GetService("TweenService")

		LocalPlayer.PlayerGui.Intro.Enabled = false
		LocalPlayer.PlayerGui.ScreenGui.Enabled = true
		game.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)

		Rayfield:Notify({
			Title = "Egg Farm: ON",
			Content = "Looking for eggs...",
			Image = 0,
			OnClick = function()
				Toggle_ServerHopFarm:Set(false)
			end,
		})

		warn("Autofarm Searching...")
		task.wait(2)

		local Islands = {}
		local LF_Eggs_Table = {}

		-- Priorities
		local LuckPriority = {
			["x25"] = 1, -- Highest priority
			["x10"] = 2,
		}

		local EggTypePriority = {
			["aura-egg"] = 1, -- Highest priority
			["void-egg"] = 2,
			["nightmare-egg"] = 3,
			["rainbow-egg"] = 4,
		}

		-- Get islands
		for _, Island in workspace.Rendered.Rifts:GetChildren() do
			if Island:FindFirstChild("Display") and Island.Display:FindFirstChild("SurfaceGui") then
				local gui = Island.Display.SurfaceGui
				if gui:FindFirstChild("Icon") and gui.Icon:FindFirstChild("Luck") then
					local Name = Island.Name
					local Luck = gui.Icon.Luck.Text
					local Timer = gui:FindFirstChild("Timer") and gui.Timer.Text or "?"
					local Height = Island.Display.CFrame.Y
					local EggCFrame = Island.Display.CFrame
					local IslandObject = Island

					table.insert(Islands, {Name, Luck, EggCFrame, Timer, Height, IslandObject})
				end
			end
		end

		-- Egg search preferences
		local EggFlags = {
			{Setting_Flag_ServerHopFarm_VoidEgg25x,      "void-egg",      "x25"},
			{Setting_Flag_ServerHopFarm_VoidEgg10x,      "void-egg",      "x10"},
			{Setting_Flag_ServerHopFarm_NightmareEgg25x, "nightmare-egg", "x25"},
			{Setting_Flag_ServerHopFarm_NightmareEgg10x, "nightmare-egg", "x10"},
			{Setting_Flag_ServerHopFarm_RainbowEgg25x,   "rainbow-egg",   "x25"},
			{Setting_Flag_ServerHopFarm_RainbowEgg10x,   "rainbow-egg",   "x10"},
			{Setting_Flag_ServerHopFarm_AuraEgg,         "aura-egg",      "x10"},
		}

		for _, flagData in ipairs(EggFlags) do
			local flag, eggName, luck = table.unpack(flagData)
			if flag then
				table.insert(LF_Eggs_Table, {eggName, luck})
			end
		end

		-- Create lookup table for matching
		local LF_Eggs_Lookup = {}
		for _, lf in LF_Eggs_Table do
			LF_Eggs_Lookup[lf[1] .. "|" .. lf[2]] = true
		end

		-- Sort islands by egg priority, then luck priority
		table.sort(Islands, function(a, b)
			local aEgg, aLuck = a[1], a[2]
			local bEgg, bLuck = b[1], b[2]
			local aEggPri = EggTypePriority[aEgg] or 0
			local bEggPri = EggTypePriority[bEgg] or 0
			if aEggPri == bEggPri then
				return (LuckPriority[aLuck] or 0) > (LuckPriority[bLuck] or 0)
			else
				return aEggPri > bEggPri
			end
		end)

		-- Attempt to find and teleport to matching island
		local FOUND = false

		for _, island in Islands do
			local Name = island[1]
			local Luck = island[2]
			local key = Name .. "|" .. Luck

			if LF_Eggs_Lookup[key] then
				local EggCFrame = island[3]
				local Timer = island[4]
				local Height = island[5]
				local IslandObject = island[6]
				local Position = EggCFrame.Position

				local msg = string.format("Egg Matched: %s | %s", Name, Luck)
				warn(msg)

				Rayfield:Notify({
					Title = "Island found!",
					Content = "Traveling to: " .. Name,
					Image = 0,
					OnClick = function() end,
				})

				GlobalEggWebhook(Name, Luck, Timer, Height)

				task.spawn(function()
					game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer(
						"Teleport",
						"Workspace.Worlds.The Overworld.Islands.Zen.Island.Portal.Spawn"
					)
				end)

				task.wait(1)

				-- Fly to island
				local HRP = LocalPlayer.Character.HumanoidRootPart
				-- change humanoid state to stitting 
				LocalPlayer.Character.Humanoid:ChangeState()
				HRP.Anchored = true
				CharacterCanColide(false)

				local distance = (HRP.Position - Position).Magnitude
				local tweenTime = nil
				

				if distance < 300 then
					tweenTime = distance / 50
				end
				
				if distance >= 300  then
					tweenTime = distance / 100
				end
				
				if distance >= 1000  then
					tweenTime = distance / 150
				end
				
				if distance >= 1000  then
					tweenTime = distance / 150
				end
				
				if distance >= 2000  then
					tweenTime = distance / 180
				end
				
				TweenService:Create(HRP, TweenInfo.new(tweenTime, Enum.EasingStyle.Sine), {CFrame = EggCFrame + Vector3.new(0, 50, 0)}):Play()

				task.wait(tweenTime + 0.7)

				CharacterCanColide(true)
				HRP.Anchored = false

				task.wait(0.5)

				-- Start hatching
				local EggName = EggNames[Name]
				task.spawn(function()
					while IslandObject do
						game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("HatchEgg", EggName, 99)
						task.wait(0.25)
					end
				end)

				-- Handle island despawn
				IslandObject.Destroying:Connect(function()
					warn("Island is despawning! Looking for a new server!")

					Rayfield:Notify({
						Title = "Island disappeared!",
						Content = "Attempting to join a new server!",
						Image = 0,
						OnClick = function() end,
					})

					task.wait(5)
					ServerHop_IY()
				end)

				FOUND = true
				break
			end
		end

		if not FOUND then
			warn("Island not found!")

			Rayfield:Notify({
				Title = "Island not found...",
				Content = "Attempting to join a new server!",
				Image = 0,
				OnClick = function() end,
			})

			task.wait(5)
			ServerHop_IY()
		end
	end
end)




function CharacterCanColide(value)
	for _, part in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
		if part:IsA("BasePart") and part.CanCollide == not value then
			part.CanCollide = value
		end
	end
end
